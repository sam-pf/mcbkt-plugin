/**
 * This module is for listening to all log data generated by CODAP, do stuff
 * on log data, and then pushing the result back into CODAP log stream.
 *
 * Author : Sam Gweon (Sam@physicsfront.com)
 * Credit : Doug Martin, Jonathan Sandoe for their code of
 *          DataflowGettingStarted DI, which gave initial guideline,
 *          motivation, and some hints to the code below.
 */

export default function (iframePhone, logdata_callback,
                         title = 'Real Time MCBKT') {

   // hidden attributes, initialized
   const client_id = title + '--' + (new Date).getTime () + '--'
      + Math.round (10000000000 * Math.random ())

   // attributes, initialized
   this.last_codap_response = null
   this.state = { // <<<
      title: title,
      version: '0.1.0',
      preventBringToFront: false,
      dimensions: { width: 500, height: 500 },
   }
   // >>>

   // hidden (and many "private") methods (by closure)
   const _destroy = () => { // <<<
      _unregister_for_logdata ()
      connection.disconnect ()
   }
   // >>>
   const _err_msg_for_unhandled_codap_request = (request) => // <<<
      'Handler not implemented for action "' +
      request.action + '" for CODAP request with resource "' +
      request.resource + '".'
   // >>>
   const _err_msg_for_unhandled_codap_response = (request) => // <<<
      'Handler not implemented for CODAP response to request "' +
      request.action + '" with resource "' + request.resource + '".'
   // >>>
   const _get_codap_request_handler = resource => { // <<<
      let handler = _request_handler_registry [resource]
      // TODO: some other more sophisticated determination of handler based
      // on resource, if necessary.
      if (handler === undefined)
         handler = () => { throw Error ('No handler for CODAP request '
               + 'with resource "' + resource + '".') }
      return handler
   }
   // >>>
   const _get_codap_response_handler = resource => { // <<<
      let handler = _response_handler_registry [resource]
      // TODO: some other more sophisticated determination of handler based
      // on resource, if necessary.
      if (handler === undefined)
         handler = () => { throw Error ('No handler for ' +
               'CODAP response to request with resource "' + resource + '".') }
      return handler
   }
   // >>>
   const _register_for_logdata = () => { // <<<
      this.send_request_to_codap ({
            action: "register",
            resource: "logMessageMonitor",
            values: {clientId: client_id, message: "*"}})
   }
   // >>>
   const _request_handler_registry = { // <<<

      interactiveState: request => {
         switch (request.action) {
            case 'get':
               return this.state
            default:
               throw Error (_err_msg_for_unhandled_codap_request (request))
         }
      },

      logMessageNotice: request => {
         switch (request.action) {
            case 'notify':
               if (request.values.formatStr.startsWith (client_id))
                  console.log ('== got boomeranged logdata: ' +
                               JSON.stringify (request.values))
               else
                  logdata_callback (request.values, logdata_report_callback)
               return {message: 'got logdata---thanks!'}
            default:
               throw Error (_err_msg_for_unhandled_codap_request (request))
         }
      },

   }
   // >>>
   const _response_handler_registry = { // <<<

      interactiveFrame: (request, response) => {
         switch (request.action) {
            case 'get':
               {
                  let frame_data = response.values
                  this.set_state (frame_data)
                  if (frame_data.savedState)
                     this.set_state (frame_data.savedState, false)
               }
               return
            default:
               throw Error (_err_msg_for_unhandled_codap_response (request))
         }
      },

      logMessage: request => {
         switch (request.action) {
            case 'notify':
               console.log ("log data were recevied well by CODAP---but " +
                           "only formatStr and replaceArgs, I think.")
               return
            default:
               throw Error (_err_msg_for_unhandled_codap_response (request))
         }
      },

      logMessageMonitor: request => {
         switch (request.action) {
            case 'register':
               console.log ('== got register data: ' + JSON.stringify (
                  request.values))
               return
            default:
               throw Error (_err_msg_for_unhandled_codap_request (request))
         }
      },

   }
   // >>>
   const _unregister_for_logdata = () => { // <<<
      this.send_request_to_codap ({
            action: "unregister",
            resource: "logMessageMonitor",
            values: {clientId: client_id}})
   }
   // >>>
   const logdata_report_callback = report => { // <<<
      if ( report.formatStr == undefined )
         report.formatStr = title + ' report'
      console.log ('== pushing logdata to CODAP: ' + JSON.stringify (report))
      // Here, we can send our own log data back to CODAP.
      this.send_request_to_codap ({
         action: "notify",
         resource: "logMessage",
         values: report
      })
   }
   // >>>

   // methods
   this.handle_codap_request = (request, callback) => { // <<<
      console.log ('== handle_codap_request: ' + JSON.stringify (request))
      let success = false, values = null
      try {
         values = _get_codap_request_handler (request.resource)(request)
         success = true
      } catch (error) {
         console.log ('** ' + error.message)
      }
      callback ({success: success, values: values})
   }
   // >>>
   this.handle_codap_response = (request, response) => { // <<<
      console.log ('== handle_codap_response: ' + JSON.stringify (response))
      // Even if response is an Array (of responses), just plug it here.
      // Maybe it will be useful for debugging.  If Array results do not
      // cause any error, then the last element will be bound as
      // last_codap_response in time any way.
      this.last_codap_response = response
      if (! response) {
         console.log ('** Request to CODAP seems to have gotten no response: ' +
                            JSON.stringify (request))
      } else if (Array.isArray (response)) { // recursion after type checking
         if (! Array.isArray (request))
            throw Error ("Type mismatch between request (non-Array) and " +
                               "response (Array).")
         if (response.length != request.length)
            throw Error ("Length mismatch between request (" + request.length +
                               ") and response (" + response.length + ").")
         request.forEach ((rq, i_rq) => this.handle_codap_response (
            rq, response [i_rq]))
      } else if (response.success) {
         console.log ('== Request to CODAP succeeded: ' +
                            JSON.stringify (request))
         try {
            _get_codap_response_handler (request.resource)(request, response)
         } catch (error) {
            console.log ('** ' + error.message)
         }
      } else {
         const msg = '** Request to CODAP failed: ' + JSON.stringify (request)
         console.log (msg)
         alert (msg)
      }
   }
   // >>>
   this.send_request_to_codap = (req, opts) => {
      if (req.resource === 'logMessage' && req.action === 'notify') {
         if (req.values !== undefined) req.values = {}
         // These fields seem unallowed.
         // req.values._source = client_id
         // req.values.source = client_id
         // quick and dirty way to prevent circular behavior
         req.values.formatStr = client_id + '--' + req.values.formatStr
      }
      connection.call (req, response => this.handle_codap_response (
         req, response, opts))
   }
   // >>>
   this.set_state = (state_in, strict = true) => { // <<<
      if (strict)
         for (const key in this.state) {
            const val = state_in [key]
            if (val !== undefined)
               this.state [key] = val
         }
      else
         for (const key in state_in)
            this.state [key] = state_in [key]
   }
   // >>>
   this.update_iframe_with_state = () => { // <<<
      this.send_request_to_codap ({
         action: 'update',
         resource: 'interactiveFrame',
         values: this.state,
      })
   }
   // >>>

   // further initialization
   const connection = new iframePhone.IframePhoneRpcEndpoint (
      this.handle_codap_request, "data-interactive", window.parent)
   this.send_request_to_codap ({action: "get", resource: "interactiveFrame"})
   _register_for_logdata ()
   window.unload = _destroy

}
